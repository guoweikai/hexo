---
title: Vue面试题
date: 2023-03-13 21:13:44
tags:
---
### 题目

1. 谈谈你对 Vue 响应式数据的理解(深入数据响应原理)?
 Vue.js 是采用数据劫持结合发布者-订阅者模式的方式
 Vue 响应式数据是 Vue.js 中最重要的概念之一，它是实现 Vue 双向数据绑定的核心机制。在 Vue 中，当我们将一个数据对象传入 Vue 实例中后，Vue 会将这个数据对象进行响应式处理，使得这个数据对象中的数据能够与视图同步更新

```js
function defineReactive(){

}
```
   
2. 谈谈你对 Vue 的双向数据绑定?

3. Vue 中如何检测数组的变化 或者 Vue 如何检测对象的变化 ?
    1. 当你利用索引直接设置一个数组项时, 例如:
       vm.items[indexOfItem] = newValue
    2. 当你修改数组的长度时, 例如: vm.items.length = newLength
    **Vue 中 数组的索引和长度变化时无法被监控的**
    通过重写了数组的 7 个方法,分别是

4. vue 中如何进行依赖收集


5. 如何理解Vue中的模板编译原理是什么?
   这个问题的核心是如何将template转换成render函数。
   将template模块转换成ast语法书 - parserHTML
   对静态语法做标记（某些节点不改变）
   重新生成代码 - codeGen,使用with语法包裹字符串
6. Vue生命周期钩子是如何实现的?
   Vue 的生命周期钩子是回调函数, 当创建组件实例的过程中会调用相应的钩子方法. 内部会对钩子进行处理, 将钩子函数维护成数组的形式

7. Vue的生命周期有哪些?
    beforeCreate 在实例初始化之后，数据观测observer 和event、watcher事件配置之前被调用
    created 实例已经创建完成，在这一步，以下配置被完成
      数据观测
      属性和方法的运算
      watch/event时间回调
      $el尚未生成
      beforeMount 在挂载之前被调用，render尚未被调用
      mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用
      beforeUpdate 数据更新时，被调用，发生在虚拟Dom重新渲染和打补丁之前
      update 由于数据更改导致的虚拟Dom重新渲染和打补丁，在这之后调用
      beforeDestroy 实例销毁之前调用
      destroyed 实例销毁之后调用，调用后Vue实例的所有东西都会被解绑，所有的事件监听会被移除，子实例被销毁，该钩子在服务端渲染期间不被调用
      keep-alive（activated & deactivated）
8. vue.mixin的使用场景和原理?
    Vue的mixin的作用就是抽离公共的业务逻辑，原理类似对象的继承，当组件初始化的时候，会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。
    如果混入的数据和本身组件的数据有冲突，采用本身的数据为准。
    缺点：命名冲突、数据来源不清晰
9.  请说明 nextTick 的原理
   1. nextTick 中的回调是在下次 Dom 更新循环结束之后执行的延迟回调
   2. 可以用于获取更新后的Dom
   3. Vue中的数据更新是异步的，使用nextTick可以保证用户定义的逻辑在更新之后执行

10.  谈谈你对 keep-alive 的了解
   keep-alive 是 Vue 内置的组件, 可以使被包含的组件保留状态, 避免重新渲染, 其有一下特性:
   1. 一版结合路由和动态组件一起使用, 用于缓存组件
   2. 提供了 include 和 exclude属性, 两者都支付字符串或正则表达式, include 表示只有名称匹配的组件会被缓存, exclude 表示任何名称匹配的组件都不会被缓存, 其中 exlude 的优先级比 include高; 
   3. 对应两个钩子函数 activated 和 deactivated, 当组件被激活时, 触发钩子函数 activeted,当组件被移除时, 触发钩子函数 deactived
11.   组件中 data 为什么是一个函数
   1. vue 中组件是用来复用的, 为了进行 data 复用, 将其定义为函数
   2. vue 组件中的 data 数据都应该是相互隔离, 互补影响的, 组件每复用一次, data 数据就应该被复制一次, 之后,当某一处复用的地方组件内 data 数据被改变时, 其他复用地方组件的 data 数据不会影响, 就需要通过 data 函数返回一个对象作为组件的状态
   3.  当我们将组件的 data 写成一个函数,数据以函数返回值形式定义, 这样每复用一次组件, 就会返回一份新的 data, 拥有自己的作用域,类似于给每个组件实例创建一个私有的数据空间,让每个组件实例维护各自的数据
   4.  当我们组件的 data 单纯的写成对象, 这些实例用的是同一个构造函数.由于 js 的特性所导致, 所有的组件实例共用了一个 data, 就会造成一个变了全部都变的结果.
   
    ```
12.   computed和watch的区别是什么？
   1. computed 和 watch都是基于 watcher 来实现的
   2. computed 的属性是具备缓存的, 依赖的值不发生变化, 对其取值时计算属性方法不会重复执行
   3. watch 是监控值的变化, 当值发生改变的时候, 会调用回调函数

13. Vue.set 方法是如何实现的
    * Vue 给对象和数据本身都添加了 dep 属性
    * 当给对象新增不存在属性的时候,就会触发对象依赖的 watcher 去更新
    * 当修改数组索引的时候, 就调用数组本身的 splice 方法去更新数组
14. Vue 为什么要用虚拟 dom
    * 虚拟 dom 就是用 js 对象来描述真实 Dom, 是对真实Dom 的抽象
    * 由于直接操作 dom 性能低, 但是 js 层的操作效率高, 可以将 Dom操作转化成对象操作. 最终通过 diff 算法比对差异进行更新 Dom
    * 虚拟 Dom 不依赖真实平台环境, 可以实现跨平台

15. Vue 中将虚拟 dom 创建成真实 dom?
16. Vue 的 diff 算法原理是什么?
    Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较
    * 先比较两个节点是不是相同节点
    * 相同节点比较属性,复用老节电
    * 先比较儿子节点,考虑老节点和新节点儿子的情况
    * 优化比较: 头头, 尾尾, 头尾,尾头
    * 比对查找,进行复用
17. 既然 vue 通过数据劫持可以精准的探测数据变化, 为什么还要进行 diff 检测差异?
    Vue 的响应式系统是 push 的代表, 当 Vue 程序初始化的时候就会对数据 data 进行依赖的收集, 一旦数据发生变化,响应式系统就会立刻得知, 因此 Vue 是一开始就知道是(在哪里发生变化了),但是这会又会产生一个问题, 如果你熟悉 vue 的响应式系统就知道, 通常一个绑定一个数据就需要一个 watcher, 一旦我们的绑定细粒度过高就会产生大量的 watcher, 这会带来内存以及依赖追踪的开销, 而细粒度过低会无法精准侦测到发生变化的组件, 然后在组件内部进行 vd Diff 获取更加具体的差异, 而 vd 则是 pull 操作,Vue 是 push+pull 结合的方式进行变化侦测的

18. 请说明 key 的作用和原理(重点总结)
   * Vue 的 patch 过程中, 通过 key 可以判断两个虚拟节点是否相同
   * 没有 key 会导致更新的时候出问题
   * 尽量不要采用索引作为 key
  **key 的使用场景**
  元素的的复用和重新渲染的区别:
  >元素的复用是在已经存在的元素上,修改其属性,  元素重新渲染, 是创建一个新的标签
  * 在元素切换中, 使用 v-if 和 v-else 切换相同的组件时, vue 为高效地渲染元素, 默认会复用已有的元素而不是重新渲染, 使用不同的 key时,会区别不同的组件
  * 在 transition 过渡中: 使用  v-if 和 v-else 切换时相同的节点, 不添加 key 时, vue 为了效率,会使用同一个元素, 只替换其中的内容, 由于没有元素的插入与删除,所以没有过渡效果,
    添加了 key,  vue 就不会复用元素了, 正常显示过渡效果
  * 在渲染列表中
    * Vue 更新使用 v-for 渲染的元素列表时, 由于无法将之前渲染的元素和新的数据项对应, 默认采用"就地更新"的策略. 如果数据的顺序改变, Vue 不会移动 Dom 元素来匹配数据的顺序, 而是更新每个 DOM 元素的内容,确保渲染内容和在数据中所有的位置一致
    * 为列表的每一个元素添加 key, 列表数据更新顺序时, 会根据 key 找到已渲染的元素进行服用, 对顺序不匹配的元素进行位置调整,更高效
  **v-for 不建议使用 index 作为 key**
1.    谈谈对组件的理解
    * 组件化开发能大幅提高应用开发效率、测试性、复用性
    * 常用的组件化技术：属性、自定义事件、插槽
    * 降低更新范围，值重新渲染变化的组件
    * 高内聚、低耦合、单向数据流
2.    请描述组件的渲染流程
    
3.    虚拟 DOM 实现原理
    虚拟 DOM 的实现原理主要包括以下 3 部分
    * 用 js 对象模拟真实 DOM 树, 对真实 DOM 进行抽象
    * diff 算法 - 比较两颗虚拟 DOM 数的差异
    * path 算法 - 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树.
4.    虚拟 DOM 的优缺点
   优点: 
    * 保证性能下限
    * 无需手动操作DOM
  缺点:
    无法进行极致优化

  链接
  [ms1](https://juejin.cn/post/6844903918753808398#heading-8)  

23. Vue 组件间通信有哪几种方式
  Vue 组件通信主要包括以下 3 类通信: 父子组件通信, 隔代组件通信, 兄弟组件通信
  (1) props /$emit 适用父子组件通信
  这种方法是 Vue 组件的基础
  (2) ref 与 $parent/ $children 使用父子组件通信
    * ref:如果在普通的 DOM 元素上使用,引用指向的就是 DOM 元素; 如果用在子组件上, 引用就指向组件实例
    * $parent/ $children: 访问 父/子实例
  (3) EventBus($emit /$on)
    这种方法通过一个空的 Vue 实例作为中央事件总线(事件中心), 用它来触发事件和监听事件, 从而实现任何组件间的通信, 包括父子,隔代, 兄弟组件
  (4) Vuex 使用于父子, 隔代,兄弟组件通信
    vuex 是一个专为 Vue.js 应用程序开发的状态管理模式, 每一个 Vuex 应用的核心就是 store(仓库).store 基于上就是一个容器, 它包含着你的应用中大部分的状态(state)

23. vue 2 和 vue 3 的区别 ,为什么使用 vue3



24. Vue 组件是 Vue 的实例吗


25. Vue 组件如何拆分


26. Vue是如何单向数据流的


每个子组件都是一个单独的单个, 组件的树形网络关系, 是解析时确定的  比如 parent ,children 
    

27. vue 的模版编译阶段都做了哪些事情
  将模版字符串编译成 ast , ast 转换成 render 函数 
  在 render 函数中创建了 虚拟 dom
  通过 renderder 比较新旧 dom ,进行更行


