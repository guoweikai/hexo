---
title: 执行上下文/作用域链/闭包
date: 2022-04-25 10:26:36
tags:
---


### 1. 对闭包的理解

闭包是指有权访问另一个函数作用域变量的函数. 创建闭包的最常见的方式就是在一个函数内创建另外一个函数,创建的函数可以访问到当前函数的局部变量

闭包有两个常用的用途

> 闭包的第一个用途是使我们再函数外部能够访问到函数内部的变量,通过使用闭包,可以通过在外部调用闭包函数,从而在外部访问到函数内部的变量,可以使用这种方法来创建私有变量




案例(经典面试题)

```js
for(var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i)
    }, 0)
}
```
<!-- 预期结构  0,1,2,3,4 -->
实际输出: 5 个 5 
分析: 由于 js 是单线程的, 按照 js 的事件循环机制,在执行同步任务 for 循环时, 异步任务 setTimeOut定时器被放到任务队列中排队等待执行, 等待 for 循环执行完,此时 i 的值已经为 5, 任务
队列中 的 5 个 setTimeOut 开始执行, 访问到 i 的值都为 5, 所以打印出来 五个 5

问题: 
全局作用域中 var 声明的变量为全局变量, 每次循环 i 的值不能被保存, 这就会出现闭包问题

解决方案

使用立即执行函数解决(闭包的方案):
```js
for(var i = 0; i < 5; i++) {
    (function(i) {
        setTimeout(function() {
            console.log(i)
        }, 0)
    })(i)
}
```
分析：
在 for 循环中，将 setTimeout 定时器放到一个立即执行函数中，将每次循环 i 的值保存到函数作用域里，作为参数传递给 setTimeout，在执行五个 setTimeout 时访问到的 i 为当前函数作用域里每次循环保存起来的 i 的值，所以打印出来0 1 2 3 4
总结：
利用函数作用域形成闭包，保存每次循环 i 的值

使用 let 解决

```js
for(let i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(i)
    }, 0)
}
```

分析：
将 for 循环中的 var 改为 let，这样在每次 for 循环之前都会生成一个块级作用域，每个块级作用域互不干扰，let 声明的变量 i 只在当前循环的块级作用域中有效，每一次循环的 i 都被声明为一个新的变量，在执行五个 setTimeout 定时器时访问到的 i 为当前块级作用域里声明的 i 的值，所以打印出来0 1 2 3 4
总结：
利用块级作用域形成闭包，保存每次循环 i 的值

第三种种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。


```js
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}

```

### 2. 对作用域、作用域链的理解
1）全局作用域和函数作用域
(1) 全局作用域
 * 最外层函数和最外层函数外面定义的变量拥有全局作用域
 * 所有未定义直接复制的变量自动声明为全局作用域
 * 所有 window 对象的属性拥有全局作用域
 * 全局作用域变量有很大的弊端, 过多的全局作用域变量会污染全局命名空间,容易引起命名冲突
(2) 函数作用域
 *   

## 问题

### js 的事件循环机制

### js 的执行上下文

执行上下文是指函数调用时在执行栈中产生的当前函数(或全球对象window)的执行环境，该环境如隔绝外部世界的容器边界，保管可访问的变量、this对象等



链接 :

[JS 闭包经典使用场景和含闭包必刷题](https://juejin.cn/post/6937469222251560990#heading-4)